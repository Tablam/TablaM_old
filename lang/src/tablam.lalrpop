use std::str::FromStr;
use core::ast::*;

grammar;

Sep<E,S>: Vec<E> =
    <v0:(<E> S)*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

Comma<E>: Vec<E> = Sep<E, ",">;
Semi<E>: Vec<E> = Sep<E, ";">;

pub Statement: Stmt = {
    "let" <n:Name> "=" <e:Expr> ";" => Stmt::Let(LetKind::Imm, n, e.into()),
    "var" <n:Name> "=" <e:Expr> ";" => Stmt::Let(LetKind::Mut, n, e.into()),
    "if" <cond:Expr> "then" <if_true:Expr> "else" <if_false:Expr> "end" =>
        Stmt::IfElse(cond.into(), if_true.into(), if_false.into()),
    "if" <cond:Expr> "then" <if_true:Expr> "end" =>
        Stmt::If(cond.into(), if_true.into()),
    "while" <cond:Expr> <body:Expr> =>
        Stmt::While(cond.into(), body.into()),
    <Expr> ";" => Stmt::Exp(<>),
};

pub Expr: Exp = {
    Add,
};

Add: Exp = {
    <l:Expr> "+" <r:Factor> => Exp::BinOp(BinOp::Plus, l.into(), r.into()),
    <l:Expr> "-" <r:Factor> => Exp::BinOp(BinOp::Minus, l.into(), r.into()),
    Factor,
};

Factor: Exp = {
    <l:Factor> "*" <r:Term> => Exp::BinOp(BinOp::Times, l.into(), r.into()),
    <l:Factor> "/" <r:Term> => Exp::BinOp(BinOp::Divide, l.into(), r.into()),
    Term,
};

Term: Exp = {
    <s:ScalarLiteral> => Exp::Scalar(s),
    <c:ColumnLiteral> => Exp::Column(c),
    <r:RowLiteral> => Exp::Row(r),
    <r:RangeLiteral> => Exp::Range(r),
    <n:Name> => Exp::Name(n),
    <BlockExpr> => <>,
};

BlockExpr: Exp = {
    "(" <ss:Statement*> <eo:Expr?> ")" => match eo {
        Some(e) => Exp::Block(ss, e.into()),
        None => Exp::Block(ss, Exp::Unit.into()),
    },
    "do" <ss:Statement*> <eo:Expr?> "end" => match eo {
        Some(e) => Exp::Block(ss, e.into()),
        None => Exp::Block(ss, Exp::Unit.into()),
    },
};

pub ScalarLiteral: Scalar = {
    <n:NumLiteral> => n,
    // <b:BoolLiteral> => b,
    <s:StringLiteral> => s,
};

pub ColumnLiteral: ColumnExp = {
    "[" <name:Name> ":" <ty:Name> ";" <es:(<Expr>)+> "]" =>
        ColumnExp { name: Some(name), ty: Some(ty), es: es },
    "[" ":" <ty:Name> ";" <es:(<Expr>)+> "]" =>
        ColumnExp { name: None, ty: Some(ty), es: es },
    "[" <es:(<Expr>)+> "]" =>
        ColumnExp { name: None, ty: None, es: es },
};

pub RangeLiteral: RangeExp = {
    "(" <start:Expr> ".." <end:Expr> ")" =>
        RangeExp { start: start.into(), end: end.into() }
};

pub RowLiteral: RowExp = {
    "{" <row:Comma<RowAssignment>> "}" => {
        // let (names, exps) = row.iter().cloned().unzip()
        // let tr: Vec<(_, _)> = row;
        let (names, exps) = row.iter().cloned().unzip();
        RowExp { names: Some(names), es: exps }
    },

    // TODO: This has a conflict for a reason I cannot immediately identify.
    // "{" <row:Comma<Expr>> "}" =>
    //     RowExp { names: None, es: row },
};

RowAssignment: (String, Exp) = {
    <n:Name> "=" <e:Expr> => (n, e),
};

Name: String = {
    r"[a-zA-Z][_a-zA-Z0-9]*" => <>.into()
};

NumLiteral: Scalar = {
    <digits:r"[0-9]+"> =>
        Scalar::I32(i32::from_str(digits).unwrap()),
    // <digits:r"[0-9]+"> "i64" =>
    //     Scalar::I64(i64::from_str(digits).unwrap()),
    // <digits:r"[0-9]+"> "i32"? =>
    //     Scalar::I32(i32::from_str(digits).unwrap()),
};

// BoolLiteral: Scalar = {
//     <b:r"true|false"> =>
//         Scalar::BOOL(bool::from_str(b).unwrap()),
// };

StringLiteral: Scalar = {
    <s:r#""[^"]*""#> => {
        let literal = &s[1..s.len()-1];
        Scalar::UTF8(encode_str(literal))
    },
};
