use std::str::FromStr;
use core::ast::*;

grammar;

Sep<E,S>: Vec<E> =
    <v0:(<E> S)*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

NonEmptySep<E,S>: Vec<E> =
    <e0:E> <e1:(S <E>)*> =>
        vec!(e0).into_iter().chain(e1).collect();

AtLeast2Sep<E,S>: Vec<E> =
    <e0:E> <e1:(S <E>)+> =>
        vec!(e0).into_iter().chain(e1).collect();

Comma<E>: Vec<E> = Sep<E, ",">;
Semi<E>: Vec<E> = Sep<E, ";">;

pub Program: Prog = {
    <FunctionDefinition*> => Prog { functions: <> },
};

pub FunctionDefinition: FunDef = {
    "fun" <name:Name> "[" <params:Comma<FunctionParam>> "]" ":" <ret_ty:Type> "=" <body:Expr> =>
        FunDef { name: name, params: params, ret_ty: ret_ty, body: body }
};

FunctionParam: (String, Ty) = {
    <n:Name> ":" <t:Type> => (n, t),
};

pub Type: Ty = {
    <ty:AtLeast2Sep<SimpleType, "->">> => Ty::Arrow(ty),
    SimpleType,
};

SimpleType: Ty = {
    <TypeName> => Ty::Star(<>),
    "(" <Type> ")" => <>,
};

TypeName: String = {
    r"[A-Z][_a-zA-Z0-9]*" => <>.into()
};

pub Statement: Stmt = {
    // TODO: fix "warning: literal out of range for i8"
    "let" <n:Name> <ty:(":" <Type>)?> "=" <e:Expr> ";" =>
        Stmt::Let(LetKind::Imm, n, ty, e.into()),
    "var" <n:Name> "=" <e:Expr> ";" =>
        Stmt::Let(LetKind::Mut, n, None, e.into()),

    "if" <cond:Term> <if_true:Term> "else" <if_false:Term> =>
        Stmt::IfElse(cond.into(), if_true.into(), if_false.into()),
    "if" <cond:Term> <if_true:Term> =>
        Stmt::If(cond.into(), if_true.into()),

    "while" <cond:Term> <body:Statement> =>
        Stmt::While(cond.into(), body.into()),
    <Expr> ";" => Stmt::Exp(<>),
    BlockStatement,
};

BlockStatement: Stmt = {
    "{" <ss:Statement+> "}" => Stmt::Block(ss),
    "do" <ss:Statement+> "end" => Stmt::Block(ss),
};

pub Expr: Exp = {
    // Function application
    <f:Term> "(" <es:Comma<Expr>> ")" => Exp::Apply(f.into(), es),
    Query,
};

Query: Exp = {
    <rel:GroupLiteral> "?" <fs:FilterList> => Exp::Query(rel.into(), fs),
    Add,
};

FilterList: Vec<FilterExp> = {
    <("#" <Filter>)+> => <>
};

Filter: FilterExp = {
    <field:Name> <op:RelOp> <e:Term> =>
        FilterExp::RelOp(op, field, e.into()),
};

RelOp: RelOp = {
    "=" => RelOp::Equals,
    "!=" => RelOp::NotEquals,
};

Add: Exp = {
    <l:Expr> "+" <r:Factor> => Exp::BinOp(BinOp::Plus, l.into(), r.into()),
    <l:Expr> "-" <r:Factor> => Exp::BinOp(BinOp::Minus, l.into(), r.into()),
    Factor,
};

Factor: Exp = {
    <l:Factor> "*" <r:GroupLiteral> => Exp::BinOp(BinOp::Times, l.into(), r.into()),
    <l:Factor> "/" <r:GroupLiteral> => Exp::BinOp(BinOp::Divide, l.into(), r.into()),
    GroupLiteral,
};

GroupLiteral: Exp = {
    <c:ColumnLiteral> => Exp::Column(c),
    <r:RowLiteral> => Exp::Row(r),
    <r:RelationLiteral> => Exp::Relation(r),
    <r:RangeLiteral> => Exp::Range(r),
    Term,
};

Term: Exp = {
    "(" ")" => Exp::Unit,
    <n:NumLiteral> => Exp::Scalar(n),
    <s:StringLiteral> => Exp::Scalar(s),
    <n:Name> => Exp::Name(n),
    "(" <Expr> ")" => <>,
    BlockExpr,
};

BlockExpr: Exp = {
    // "{" <ss:Statement*> <e:Expr> "}" => Exp::Block(ss, e.into()),
    "do" <ss:Statement*> <e:Expr> "end" => Exp::Block(ss, e.into()),
};

pub ColumnLiteral: ColumnExp = {
    "[" <name:(<Name> ":")?> <ty:Type> ";" <es:Term+> "]" =>
        ColumnExp { name: name, ty: Some(ty), es: es },
    "[" <es:Term+> "]" =>
        ColumnExp { name: None, ty: None, es: es },
};

pub RangeLiteral: RangeExp = {
    "(" <start:Term> ".." <end:Term> ")" =>
        RangeExp { start: start.into(), end: end.into() }
};

pub RowLiteral: RowExp = {
    "{" <row:NonEmptySep<RowAssignment, ",">> "}" => {
        let (names, exps) = row.iter().cloned().unzip();
        RowExp { names: Some(names), es: exps }
    },

    // TODO: fix -- without r, gets confused with block
    "{" <row:NonEmptySep<Term, ",">> "}" =>
        RowExp { names: None, es: row },
};

RowAssignment: (String, Exp) = {
    <n:Name> "=" <e:Term> => (n, e),
};

pub RelationLiteral: RelationExp = {
    // Row format
    "[<" <names:Comma<Name>> ";" <data:Semi<Term+>> ">]" =>
        RelationExp { rel_type: RelType::Row, names: names, data: data },

    // Col format
    "[|" <cols:Semi<ColAssignment>> "|]" => {
        let (names, data) = cols.iter().cloned().unzip();
        RelationExp { rel_type: RelType::Col, names: names, data: data }
    },
};

ColAssignment: (String, Vec<Exp>) = {
    <n:Name> "=" <es:Term+> => (n, es),
};

Name: String = {
    r"[a-z][_a-zA-Z0-9]*" => <>.into()
};

NumLiteral: Scalar = {
    <digits:r"[0-9]+"> "i32"? =>
        Scalar::I32(i32::from_str(digits).unwrap()),
    <digits:r"[0-9]+"> "i64" =>
        Scalar::I64(i64::from_str(digits).unwrap()),
};

// BoolLiteral: Scalar = {
//     <b:r"true|false"> =>
//         Scalar::BOOL(bool::from_str(b).unwrap()),
// };

StringLiteral: Scalar = {
    <s:r#""[^"]*""#> => {
        let literal = &s[1..s.len()-1];
        Scalar::UTF8(encode_str(literal))
    },
};
